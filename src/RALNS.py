from copy import deepcopy
import numpy as np
import random
from vehicle import Car, sync_times_and_waypoints
from input_data import SG, orders_list
from value_func import calc_slack_time, calc_extra_cost
import random

max_rwd = -0x3f3f3f3f
min_rwd = 0x3f3f3f3f

""" refer to our paper """

def roulette_wheel_selection(A):
    """ generated by chatgpt """
    total_weight = sum(A)
    r = random.uniform(0, total_weight)
    current_sum = 0
    for i, weight in enumerate(A):
        current_sum += weight
        if r <= current_sum:
            return i
    return random.randint(0, len(A)-1)
        
def degree_between_order_x_and_order_y(xidx, yidx):
    return float(SG[xidx,yidx] + SG[yidx,xidx])

def calc_sg_degree(order_idx_: int, orders_idx_list_: list, noise):
    dg = 0
    for idx in orders_idx_list_:
        dg += SG[order_idx_, idx] + SG[idx, order_idx_]
    return float(dg * noise)

def calc_regret(order_idx_, cars_list_, noise):
    """ regret_value """
    car: Car
    cars_insert_info_for_order_idx_tup = []        
    for car in cars_list_:
        if car.is_idle() == True:
            continue
        insert_cost, insert_orig_idx, insert_dest_idx = car.insert_to_car_based_value_function(orders_list[order_idx_], orders_list, calc_extra_cost)
        if insert_cost != 0x3f3f3f3f:
            cars_insert_info_for_order_idx_tup.append((insert_cost, car.id, insert_orig_idx, insert_dest_idx))
    if len(cars_insert_info_for_order_idx_tup) <= 1:
        return -1
    sorted_cars_insert_info_for_order_idx_tup = sorted(cars_insert_info_for_order_idx_tup, key=lambda tup: tup[0], reverse=False)
    regret_val = sorted_cars_insert_info_for_order_idx_tup[0][0] - sorted_cars_insert_info_for_order_idx_tup[1][0]
    return float(regret_val * noise)

def calc_greedy_cost(order_idx_, cars_list_, noise):
    car: Car
    greedy_cost = 0x3f3f3f3f
    for car in cars_list_:
        if car.is_idle() == True:
            continue
        insert_cost, insert_orig_idx, insert_dest_idx = car.insert_to_car_based_value_function(orders_list[order_idx_], orders_list, calc_extra_cost)
        greedy_cost = min(greedy_cost, insert_cost)
    return greedy_cost


class RALNS():
    def __init__(self, insert_operator_num, remove_operator_num, r_x, r_y, r_z, learning_rate) -> None:
        self.insert_op_weight = [10] * insert_operator_num
        self.remove_op_weight = [10] * remove_operator_num
        self.learning_rate = learning_rate
        self.r_x = r_x
        self.r_y = r_y
        self.r_z = r_z
    
    def get_removable_orders_idx(self, cars_list_):
        """ 
            wpidx + r_x (inclusive) and everything after can be deleted. 
            For example, if wpidx + r_x = 2, then all passengers from position 2 onward (including 2) can be deleted.
        """
        removable_orders_idx = []
        car: Car
        for car in cars_list_:
            if car.over_highway() == True:
                continue
            if car.wpidx == 0 and len(car.serving_list) != 0:
                removable_orders_idx += car.serving_list
                continue
            pivot_idx = car.wpidx + self.r_x
            if pivot_idx > len(car.waypoints) // 2:
                continue
            pivot_time = car.times[pivot_idx] + self.r_y
            for i in range(pivot_idx, len(car.waypoints) // 2 + 1):
                if car.times[i] <= pivot_time:
                    continue
                if car.waypoints[i] < 0: # type: ignore
                    raise Exception(f" !!! RALNS.py -> line 69")
                removable_orders_idx.append(car.waypoints[i])
        return removable_orders_idx

    def R_0(self, removable_orders_idx_):
        """ SG remove """
        seed_order_idx = random.choice(removable_orders_idx_)
        orders_idx_with_seed_dg_pr = [(order_idx, degree_between_order_x_and_order_y(order_idx,seed_order_idx)) for order_idx in removable_orders_idx_]
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        sorted_orders_idx_with_seed_dg_pr = sorted(orders_idx_with_seed_dg_pr, key=lambda pr: pr[1], reverse=True)[:max_remove_number]        
        
        removed_orders_idx = [pr[0] for pr in sorted_orders_idx_with_seed_dg_pr]
        if seed_order_idx not in removed_orders_idx:
            removed_orders_idx.append(seed_order_idx)
        return removed_orders_idx
    def R_1(self, removable_orders_idx_):
        """ Random remove """
        min_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        removed_orders_idx = random.sample(removable_orders_idx_, random.randint(min_remove_number, max_remove_number))
        return removed_orders_idx
    
    def R_2(self, removable_orders_idx_, cars_list_):
        """ remove min slktime """
        removable_orders_slktime = []
        car: Car
        for removable_order_idx in removable_orders_idx_:
            for car in cars_list_:
                if removable_order_idx not in car.waypoints:
                    continue
                o_time_idx = car.waypoints.index(removable_order_idx)
                d_time_idx = car.waypoints.index(-removable_order_idx)
                removable_orders_slktime.append(min(orders_list[removable_order_idx].ddlo - car.times[o_time_idx], orders_list[removable_order_idx].ddld - car.times[d_time_idx]))
                break
        if len(removable_orders_slktime) != len(removable_orders_idx_):
            print(f" >>> removable_orders_slktime: {removable_orders_slktime}")
            print(f" >>> removable_orders_idx_: {removable_orders_idx_}")
            raise Exception("NoOoOoOoOoOoO WayYyYyYy !!!")
        orders_idx_and_slktime_pr = [(removable_orders_idx_[i], removable_orders_slktime[i]) for i in range(len(removable_orders_idx_))]  
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1])[:max_remove_number]
        removed_orders_idx = [pr[0] for pr in sorted_orders_idx_and_slktime_pr]
        return removed_orders_idx
    
    def R_3(self, removable_orders_idx_, cars_list_):
        """ remove max extra cost """
        removable_orders_extra_cost = []
        for removable_order_idx in removable_orders_idx_:
            for car in cars_list_:
                if removable_order_idx not in car.waypoints:
                    continue
                new_waypoints = deepcopy(car.waypoints)
                new_times = deepcopy(car.times)
                o_time_idx = car.waypoints.index(removable_order_idx)
                d_time_idx = car.waypoints.index(-removable_order_idx)
                del new_waypoints[d_time_idx]
                del new_waypoints[o_time_idx]
                del new_times[d_time_idx]
                del new_times[o_time_idx]
                bl, new_times = sync_times_and_waypoints(new_waypoints, new_times, car.wpidx, orders_list, car.city)
                removable_orders_extra_cost.append(calc_extra_cost(new_waypoints, new_times, car.wpidx, orders_list, removable_order_idx))
                break
        if len(removable_orders_extra_cost) != len(removable_orders_idx_):
            print(f" >>> removable_orders_slktime: {removable_orders_extra_cost}")
            print(f" >>> removable_orders_idx_: {removable_orders_idx_}")
            raise Exception("NoOoOoOoOoOoO WayYyYyYy !!!")
        orders_idx_and_extracost_pr = [(removable_orders_idx_[i], removable_orders_extra_cost[i])  for i in range(len(removable_orders_idx_))]
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        sorted_orders_idx_and_extracost_pr = sorted(orders_idx_and_extracost_pr, key=lambda pr: pr[1], reverse=True)[:max_remove_number]
        removed_orders_idx = [pr[0] for pr in sorted_orders_idx_and_extracost_pr]
        return removed_orders_idx
    
    def I_0(self, removed_orders_idx_, others_orders_list_):
        """ SG increase insert """
        removed_orders_idx_pr = [(order_idx, calc_sg_degree(order_idx, others_orders_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=False)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
    
    def I_1(self, removed_orders_idx_, others_orders_list_):
        """ SG decrease insert """
        removed_orders_idx_pr = [(order_idx,  calc_sg_degree(order_idx, others_orders_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=True)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
    
    def I_2(self, removed_orders_idx_, cars_list_):
        """ regret insert """
        removed_orders_idx_pr = [(order_idx, calc_regret(order_idx, cars_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=True)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
    
    def I_3(self, removed_orders_idx_, cars_list_):
        """ greedy insert (min extra cost) """
        removed_orders_idx_pr = [(order_idx, calc_greedy_cost(order_idx, cars_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=False)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
        
    def choose_insert_operator(self):
        return roulette_wheel_selection(self.insert_op_weight)
        
    def choose_remove_operator(self):
        return roulette_wheel_selection(self.remove_op_weight)

    def calc_obj_value(self, cars_list_):
        """ object or called reward function (larger F, better result) """
        cnt = obj1 = obj2 = obj3 = obj4 = 0
        car: Car
        for car in cars_list_:
            if car.is_idle() == True:
                continue
            obj1 += len(car.serving_list)
            obj2 += car.times[-1] - car.times[0]
            cnt += 1
            obj3 += calc_slack_time(car.waypoints, car.times, car.wpidx, orders_list, -1)
        F = obj1*1000 - obj2/cnt*1 - cnt*50
        return obj1, F
    
    def update_prob(self, old_obj_, new_obj_, R_id_1, R_id_2, I_id_):
        global max_rwd, min_rwd
        
        if new_obj_ > old_obj_:
            max_rwd = max(max_rwd, np.log2(new_obj_ - old_obj_ + 1))
            min_rwd = min(min_rwd, np.log2(new_obj_ - old_obj_ + 1))
            rwd = np.log2(new_obj_ - old_obj_ + 1) / 10
            self.remove_op_weight[R_id_1] = self.remove_op_weight[R_id_1] * self.learning_rate +  rwd / 2
            self.remove_op_weight[R_id_2] = self.remove_op_weight[R_id_2] * self.learning_rate + rwd / 2
            self.insert_op_weight[I_id_] = self.insert_op_weight[I_id_] * self.learning_rate + rwd
        elif new_obj_ == old_obj_:
            pass
        else:
            max_rwd = max(max_rwd, np.log2(old_obj_ - new_obj_ + 1))             
            min_rwd = min(min_rwd, np.log2(old_obj_ - new_obj_ + 1))
            rwd = np.log2(old_obj_ - new_obj_ + 1) / 10
            r1_bkup = self.remove_op_weight[R_id_1]
            r2_bkup = self.remove_op_weight[R_id_2]
            i_bkup = self.insert_op_weight[I_id_]
            
            self.remove_op_weight[R_id_1] = self.remove_op_weight[R_id_1] * self.learning_rate - rwd / 2
            self.remove_op_weight[R_id_2] = self.remove_op_weight[R_id_2] * self.learning_rate - rwd / 2
            self.insert_op_weight[I_id_] = self.insert_op_weight[I_id_] * self.learning_rate - rwd
            
            if self.remove_op_weight[R_id_1] < 1:
                self.remove_op_weight[R_id_1] = r1_bkup
            if self.remove_op_weight[R_id_2] < 1:                                  
                self.remove_op_weight[R_id_2] = r2_bkup
            if self.insert_op_weight[I_id_] < 1:
                self.insert_op_weight[I_id_] = i_bkup

""" TEST """
# ralns = RALNS(4,3,1,300,0.5,0.95)
# print(ralns.insert_op_prob)
# print(ralns.remove_op_prob)
# print(ralns.wheel_insert_op())
# print(ralns.wheel_insert_op()) 
# print(ralns.wheel_insert_op()) 

def get_min_max():
    """ for normalization """
    global min_rwd, max_rwd
    print(f" >>> DEBUG: {min_rwd}, {max_rwd}")
